"""
Strategy Engine Module

This module provides the core strategy engine for the trading system, enabling
the registration, configuration, and execution of trading strategies.

Features:
- Strategy registration and lifecycle management
- Market data distribution to registered strategies
- Signal collection and distribution
- Parameter management and validation
- Backtesting support
"""

import asyncio
import logging
import uuid
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Callable, Awaitable

from trading_system.core.message_bus import MessageBus
from trading_system.market_data.market_data_types import MarketData

# Get logger
logger = logging.getLogger(__name__)

class SignalType(Enum):
    """Types of trading signals."""
    ENTRY = "entry"     # Enter a new position
    EXIT = "exit"       # Exit an existing position
    ADJUST = "adjust"   # Adjust an existing position
    ALERT = "alert"     # Informational alert only

class SignalDirection(Enum):
    """Direction of trading signals."""
    LONG = "long"       # Long/buy position
    SHORT = "short"     # Short/sell position
    NEUTRAL = "neutral" # No directional bias

class StrategyStatus(Enum):
    """Status of a trading strategy."""
    INITIALIZED = "initialized"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"

class StrategyParameters:
    """Container for strategy parameters with validation."""
    
    def __init__(self, params: Dict[str, Any] = None):
        """Initialize strategy parameters.
        
        Args:
            params: Dictionary of parameter key-value pairs
        """
        self.params = params or {}
        
    def get(self, key: str, default: Any = None) -> Any:
        """Get parameter value with optional default.
        
        Args:
            key: Parameter key
            default: Default value if key not found
            
        Returns:
            Parameter value or default
        """
        return self.params.get(key, default)
    
    def set(self, key: str, value: Any) -> None:
        """Set parameter value.
        
        Args:
            key: Parameter key
            value: Parameter value
        """
        self.params[key] = value
        
    def update(self, params: Dict[str, Any]) -> None:
        """Update multiple parameters.
        
        Args:
            params: Dictionary of parameter key-value pairs
        """
        self.params.update(params)
        
    def validate(self, required_keys: List[str] = None) -> bool:
        """Validate that required parameters are present.
        
        Args:
            required_keys: List of required parameter keys
            
        Returns:
            True if validation passes, False otherwise
        """
        if required_keys:
            return all(key in self.params for key in required_keys)
        return True
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert parameters to dictionary.
        
        Returns:
            Dictionary of parameters
        """
        return self.params.copy()

class TradingSignal:
    """Trading signal generated by a strategy."""
    
    def __init__(
        self,
        strategy_id: str,
        signal_id: str,
        ticker: str,
        signal_type: SignalType,
        direction: SignalDirection,
        timestamp: datetime,
        params: Dict[str, Any] = None
    ):
        """Initialize trading signal.
        
        Args:
            strategy_id: ID of the strategy that generated the signal
            signal_id: Unique ID for the signal
            ticker: Trading instrument ticker
            signal_type: Type of signal (entry, exit, etc.)
            direction: Direction of signal (long, short, neutral)
            timestamp: Timestamp when signal was generated
            params: Additional parameters for the signal
        """
        self.strategy_id = strategy_id
        self.signal_id = signal_id
        self.ticker = ticker
        self.signal_type = signal_type
        self.direction = direction
        self.timestamp = timestamp
        self.params = params or {}
        
        # Execution tracking
        self.executed = False
        self.execution_timestamp = None
        self.execution_result = None
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary.
        
        Returns:
            Dictionary representation of signal
        """
        return {
            "strategy_id": self.strategy_id,
            "signal_id": self.signal_id,
            "ticker": self.ticker,
            "signal_type": self.signal_type.value,
            "direction": self.direction.value,
            "timestamp": self.timestamp.isoformat(),
            "params": self.params,
            "executed": self.executed,
            "execution_timestamp": self.execution_timestamp.isoformat() if self.execution_timestamp else None,
            "execution_result": self.execution_result
        }
    
    def mark_executed(self, result: Dict[str, Any]) -> None:
        """Mark signal as executed with result.
        
        Args:
            result: Execution result
        """
        self.executed = True
        self.execution_timestamp = datetime.now()
        self.execution_result = result

class Strategy:
    """Base class for trading strategies."""
    
    def __init__(
        self,
        strategy_id: str,
        name: str,
        parameters: StrategyParameters = None
    ):
        """Initialize strategy.
        
        Args:
            strategy_id: Unique ID for the strategy
            name: Display name for the strategy
            parameters: Strategy parameters
        """
        self.strategy_id = strategy_id
        self.name = name
        self.parameters = parameters or StrategyParameters()
        self.status = StrategyStatus.INITIALIZED
        self.supported_tickers = []
        self.signals = []
        self.last_update = datetime.now()
        
    async def initialize(self) -> None:
        """Initialize the strategy."""
        pass
    
    async def start(self) -> None:
        """Start the strategy."""
        self.status = StrategyStatus.RUNNING
        
    async def stop(self) -> None:
        """Stop the strategy."""
        self.status = StrategyStatus.STOPPED
        
    async def pause(self) -> None:
        """Pause the strategy."""
        self.status = StrategyStatus.PAUSED
        
    async def process_market_data(self, market_data: MarketData) -> List[TradingSignal]:
        """Process market data and generate signals.
        
        Args:
            market_data: Market data to process
            
        Returns:
            List of generated trading signals
        """
        return []
    
    def create_signal(
        self,
        ticker: str,
        signal_type: SignalType,
        direction: SignalDirection,
        params: Dict[str, Any] = None
    ) -> TradingSignal:
        """Create a new trading signal.
        
        Args:
            ticker: Trading instrument ticker
            signal_type: Type of signal
            direction: Direction of signal
            params: Additional parameters for the signal
            
        Returns:
            Created trading signal
        """
        signal_id = str(uuid.uuid4())
        timestamp = datetime.now()
        
        signal = TradingSignal(
            strategy_id=self.strategy_id,
            signal_id=signal_id,
            ticker=ticker,
            signal_type=signal_type,
            direction=direction,
            timestamp=timestamp,
            params=params
        )
        
        self.signals.append(signal)
        return signal
    
    async def on_signal_executed(self, signal: TradingSignal, result: Dict[str, Any]) -> None:
        """Handle signal execution result.
        
        Args:
            signal: Trading signal that was executed
            result: Execution result
        """
        # Find signal in strategy signals
        for s in self.signals:
            if s.signal_id == signal.signal_id:
                s.mark_executed(result)
                break
    
    def get_parameter(self, key: str, default: Any = None) -> Any:
        """Get strategy parameter.
        
        Args:
            key: Parameter key
            default: Default value if key not found
            
        Returns:
            Parameter value or default
        """
        return self.parameters.get(key, default)
    
    def set_parameter(self, key: str, value: Any) -> None:
        """Set strategy parameter.
        
        Args:
            key: Parameter key
            value: Parameter value
        """
        self.parameters.set(key, value)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert strategy to dictionary.
        
        Returns:
            Dictionary representation of strategy
        """
        return {
            "strategy_id": self.strategy_id,
            "name": self.name,
            "status": self.status.value,
            "supported_tickers": self.supported_tickers,
            "parameters": self.parameters.to_dict(),
            "signal_count": len(self.signals),
            "last_update": self.last_update.isoformat()
        }

class StrategyEngine:
    """Strategy engine for managing and executing strategies."""
    
    def __init__(self, message_bus: MessageBus = None):
        """Initialize strategy engine.
        
        Args:
            message_bus: Message bus for distributing signals
        """
        self.strategies = {}
        self.message_bus = message_bus
        self.is_running = False
        
    async def initialize(self) -> None:
        """Initialize the strategy engine."""
        if self.message_bus is None:
            self.message_bus = MessageBus()
            await self.message_bus.initialize()
    
    async def start(self) -> None:
        """Start the strategy engine and all registered strategies."""
        if self.is_running:
            return
            
        logger.info("Starting strategy engine")
        self.is_running = True
        
        # Start all strategies
        for strategy_id, strategy in self.strategies.items():
            try:
                await strategy.start()
                logger.info(f"Started strategy: {strategy.name} ({strategy_id})")
            except Exception as e:
                logger.error(f"Error starting strategy {strategy_id}: {str(e)}")
                strategy.status = StrategyStatus.ERROR
    
    async def stop(self) -> None:
        """Stop the strategy engine and all registered strategies."""
        if not self.is_running:
            return
            
        logger.info("Stopping strategy engine")
        self.is_running = False
        
        # Stop all strategies
        for strategy_id, strategy in self.strategies.items():
            try:
                await strategy.stop()
                logger.info(f"Stopped strategy: {strategy.name} ({strategy_id})")
            except Exception as e:
                logger.error(f"Error stopping strategy {strategy_id}: {str(e)}")
    
    def register_strategy(self, strategy: Strategy) -> None:
        """Register a strategy with the engine.
        
        Args:
            strategy: Strategy to register
        """
        self.strategies[strategy.strategy_id] = strategy
        logger.info(f"Registered strategy: {strategy.name} ({strategy.strategy_id})")
    
    def unregister_strategy(self, strategy_id: str) -> None:
        """Unregister a strategy from the engine.
        
        Args:
            strategy_id: ID of the strategy to unregister
        """
        if strategy_id in self.strategies:
            del self.strategies[strategy_id]
            logger.info(f"Unregistered strategy: {strategy_id}")
    
    async def process_market_data(self, market_data: MarketData) -> None:
        """Process market data and distribute to relevant strategies.
        
        Args:
            market_data: Market data to process
        """
        if not self.is_running:
            return
            
        # Send market data to each strategy that supports this ticker
        for strategy_id, strategy in self.strategies.items():
            if strategy.status != StrategyStatus.RUNNING:
                continue
                
            # Check if strategy supports this ticker
            if market_data.ticker in strategy.supported_tickers:
                try:
                    # Process market data in strategy
                    signals = await strategy.process_market_data(market_data)
                    
                    # Publish any generated signals
                    if signals:
                        for signal in signals:
                            await self._publish_signal(signal)
                            
                except Exception as e:
                    logger.error(f"Error processing market data in strategy {strategy_id}: {str(e)}")
                    strategy.status = StrategyStatus.ERROR
    
    async def _publish_signal(self, signal: TradingSignal) -> None:
        """Publish a trading signal to the message bus.
        
        Args:
            signal: Trading signal to publish
        """
        if self.message_bus:
            topic = f"signals.new.{signal.strategy_id}.{signal.ticker}"
            await self.message_bus.publish(topic, signal)
            await self.message_bus.publish("signals.new", signal)
            logger.info(f"Published signal: {signal.signal_type.value} {signal.direction.value} for {signal.ticker}")
    
    async def on_signal_executed(self, signal: TradingSignal, result: Dict[str, Any]) -> None:
        """Handle signal execution result.
        
        Args:
            signal: Trading signal that was executed
            result: Execution result
        """
        # Mark signal as executed
        signal.mark_executed(result)
        
        # Notify strategy of execution
        strategy = self.strategies.get(signal.strategy_id)
        if strategy:
            await strategy.on_signal_executed(signal, result)
            
        # Publish execution result
        if self.message_bus:
            topic = f"signals.executed.{signal.strategy_id}.{signal.ticker}"
            await self.message_bus.publish(topic, signal)
            await self.message_bus.publish("signals.executed", signal)
            logger.info(f"Published signal execution: {signal.signal_id} for {signal.ticker}")
    
    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        """Get a strategy by ID.
        
        Args:
            strategy_id: ID of the strategy to get
            
        Returns:
            Strategy or None if not found
        """
        return self.strategies.get(strategy_id)
    
    def get_strategies(self) -> Dict[str, Strategy]:
        """Get all registered strategies.
        
        Returns:
            Dictionary of strategy ID to strategy
        """
        return self.strategies.copy()
    
    def get_strategy_status(self, strategy_id: str) -> Optional[StrategyStatus]:
        """Get the status of a strategy.
        
        Args:
            strategy_id: ID of the strategy to get status for
            
        Returns:
            Strategy status or None if not found
        """
        strategy = self.strategies.get(strategy_id)
        if strategy:
            return strategy.status
        return None 